var documenterSearchIndex = {"docs":
[{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We benchmarked the performance of this package on different graphs. The results are shown below.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: )","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"For more details, please refer to this repository: https://github.com/ArrogantGao/TreeWidthSolver_benchmark.","category":"page"},{"location":"contractionorder/#Contraction-Order","page":"Contraction Order","title":"Contraction Order","text":"","category":"section"},{"location":"contractionorder/","page":"Contraction Order","title":"Contraction Order","text":"This package can be used as backend for finding the optimal tensor network contraction order.","category":"page"},{"location":"contractionorder/#OMEinsumContractionOrders.jl","page":"Contraction Order","title":"OMEinsumContractionOrders.jl","text":"","category":"section"},{"location":"contractionorder/","page":"Contraction Order","title":"Contraction Order","text":"A new optimizer has been added in OMEinsumContractionOrders.jl.","category":"page"},{"location":"contractionorder/","page":"Contraction Order","title":"Contraction Order","text":"Here is an example of usage:","category":"page"},{"location":"contractionorder/","page":"Contraction Order","title":"Contraction Order","text":"julia> using OMEinsum, OMEinsumContractionOrders\n\n# define the contraction using Einstein summation\njulia> code = ein\"ijl, ikm, jkn, l, m, n -> \"\nijl, ikm, jkn, l, m, n -> \n\nulia> optimizer = ExactTreewidth()\nExactTreewidth{GreedyMethod{Float64, Float64}}(GreedyMethod{Float64, Float64}(0.0, 0.0, 1))\n\n# set the size of the indices\njulia> size_dict = uniformsize(code, 2)\nDict{Char, Int64} with 6 entries:\n  'n' => 2\n  'j' => 2\n  'i' => 2\n  'l' => 2\n  'k' => 2\n  'm' => 2\n\njulia> optcode = optimize_code(code, size_dict, optimizer)\nn, n -> \n├─ jk, jkn -> n\n│  ├─ ij, ik -> jk\n│  │  ├─ ijl, l -> ij\n│  │  │  ├─ ijl\n│  │  │  └─ l\n│  │  └─ ikm, m -> ik\n│  │     ├─ ikm\n│  │     └─ m\n│  └─ jkn\n└─ n\n\n# check the complexity\njulia> contraction_complexity(optcode, size_dict)\nTime complexity: 2^5.087462841250339\nSpace complexity: 2^2.0\nRead-write complexity: 2^5.882643049361841\n\n# check the results\njulia> A = rand(2, 2, 2); B = rand(2, 2, 2); C = rand(2, 2, 2); D = rand(2); E = rand(2); F = rand(2);\n\njulia> code(A, B, C, D, E, F) ≈ optcode(A, B, C, D, E, F)\ntrue","category":"page"},{"location":"contractionorder/#TensorOperations.jl","page":"Contraction Order","title":"TensorOperations.jl","text":"","category":"section"},{"location":"contractionorder/","page":"Contraction Order","title":"Contraction Order","text":"This optimizer will be used as an extension of TensorOperations.jl in the future, see this PR. We compared the performance of this method against the default optimizer of TensorOperations.jl based on exhaustive searching, the results is shown below.","category":"page"},{"location":"contractionorder/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contractionorder/","page":"Contraction Order","title":"Contraction Order","text":"The results shown that the tree width based solver is faster for some graph similar to trees. For more details, please see the benchmark repo: https://github.com/ArrogantGao/TreeWidthSolver_benchmark.","category":"page"},{"location":"manual/#Manual-for-TreeWidthSolver.jl","page":"Manual","title":"Manual for TreeWidthSolver.jl","text":"","category":"section"},{"location":"manual/#API","page":"Manual","title":"API","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#Data-Type","page":"Manual","title":"Data Type","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MaskedBitGraph","category":"page"},{"location":"manual/#TreeWidthSolver.MaskedBitGraph","page":"Manual","title":"TreeWidthSolver.MaskedBitGraph","text":"mutable struct MaskedBitGraph{INT}\n\nA mutable struct representing a masked bit graph.\n\nFields\n\nMaskedBitGraph::Vector{INT}: Stores the adjacency matrix as a vector of BitStr.\nfadjlist::Vector{Vector{Int}}: Stores the adjacency list, providing information about the sparse graph.\nmask::INT: The mask for the graph.\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"DecompositionTreeNode","category":"page"},{"location":"manual/#TreeWidthSolver.DecompositionTreeNode","page":"Manual","title":"TreeWidthSolver.DecompositionTreeNode","text":"mutable struct DecompositionTreeNode{T}\n\nA mutable struct representing a node in a tree decomposition.\n\nFields\n\nbag::Set{T}: The bag of the node, which is a set of elements of type T.\nparent::Union{DecompositionTreeNode{T}, Nothing}: The parent node of the current node. It can be either a DecompositionTreeNode{T} or Nothing if the current node is the root.\nchildren::Vector{DecompositionTreeNode{T}}: The children nodes of the current node, stored in a vector.\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"TreeDecomposition","category":"page"},{"location":"manual/#TreeWidthSolver.TreeDecomposition","page":"Manual","title":"TreeWidthSolver.TreeDecomposition","text":"struct TreeDecomposition{TW, TL}\n\nA struct representing a tree decomposition.\n\nFields\n\ntw::TW: The treewidth of the decomposition.\ntree::DecompositionTreeNode{TL}: The root node of the decomposition tree.\n\n\n\n\n\n","category":"type"},{"location":"manual/#IO-for-Graphs","page":"Manual","title":"IO for Graphs","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"graph_from_gr","category":"page"},{"location":"manual/#TreeWidthSolver.graph_from_gr","page":"Manual","title":"TreeWidthSolver.graph_from_gr","text":"graph_from_gr(filename)\n\nReads a graph from a file in the .gr format (PACE format) and returns a SimpleGraph object.\n\nArguments\n\nfilename: The path to the input file.\n\nReturns\n\ngraph: A SimpleGraph object representing the graph.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"save_graph","category":"page"},{"location":"manual/#TreeWidthSolver.save_graph","page":"Manual","title":"TreeWidthSolver.save_graph","text":"function save_graph(g::SimpleGraph, filename)\n\nThe graph will be saved as .gr format, in PACE format, where the first line is p tw nv ne, and the following lines are the edges src dst\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"graph_from_tuples","category":"page"},{"location":"manual/#TreeWidthSolver.graph_from_tuples","page":"Manual","title":"TreeWidthSolver.graph_from_tuples","text":"graph_from_tuples(n::Int, edgs)\n\nConstructs a graph from a list of tuples representing edges.\n\nArguments\n\nn::Int: The number of vertices in the graph.\nedgs: A list of tuples representing the edges of the graph.\n\nReturns\n\nA graph object.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Hypergraph","page":"Manual","title":"Hypergraph","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"line_graph","category":"page"},{"location":"manual/#TreeWidthSolver.line_graph","page":"Manual","title":"TreeWidthSolver.line_graph","text":"line_graph(adjacency_mat::SparseMatrixCSC)\n\nConstructs the line graph of a given graph represented by its adjacency matrix.\n\nArguments\n\nadjacency_mat::SparseMatrixCSC: The adjacency matrix of the input graph, where the columns represent the vertices and the rows represent the edges. The value is true if the edge is connected to the vertex.\n\nReturns\n\ng::SimpleGraph: The line graph of the input graph.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"simple_graph","category":"page"},{"location":"manual/#TreeWidthSolver.simple_graph","page":"Manual","title":"TreeWidthSolver.simple_graph","text":"simple_graph(adjacency_mat::SparseMatrixCSC)\n\nConstructs a simple undirected graph from a sparse adjacency matrix.\n\nArguments\n\nadjacency_mat::SparseMatrixCSC: The sparse adjacency matrix representing the graph.\n\nReturns\n\ng::SimpleGraph: The constructed simple undirected graph.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"adjacency_mat","category":"page"},{"location":"manual/#TreeWidthSolver.adjacency_mat","page":"Manual","title":"TreeWidthSolver.adjacency_mat","text":"adjacency_mat(graph::SimpleGraph)\n\nConstructs the adjacency matrix of a given SimpleGraph.\n\nArguments\n\ngraph::SimpleGraph: The input graph.\n\nReturns\n\nSparseMatrixCSC{Int}: The adjacency matrix of the graph.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Treewidth","page":"Manual","title":"Treewidth","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"exact_treewidth","category":"page"},{"location":"manual/#TreeWidthSolver.exact_treewidth","page":"Manual","title":"TreeWidthSolver.exact_treewidth","text":"exact_treewidth(g::SimpleGraph{TG}; weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TW}\n\nCompute the exact treewidth of a given graph g using the BT algorithm.\n\nArguments\n\ng::SimpleGraph{TG}: The input graph.\nweights::Vector{TW} = ones(nv(g)): The weights of the vertices in the graph. Default is equal weights for all vertices.\nverbose::Bool = false: Whether to print verbose output. Default is false.\n\nReturns\n\ntw: The treewidth of the graph.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"decomposition_tree","category":"page"},{"location":"manual/#TreeWidthSolver.decomposition_tree","page":"Manual","title":"TreeWidthSolver.decomposition_tree","text":"decomposition_tree(g::SimpleGraph{TG}; labels::Vector{TL} = collect(1:nv(g)), weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TW, TL}\n\nConstructs a decomposition tree for a given simple graph g.\n\nArguments\n\ng::SimpleGraph{TG}: The input graph.\nlabels::Vector{TL}: (optional) The labels for the vertices of the graph. Default is collect(1:nv(g)).\nweights::Vector{TW}: (optional) The weights for the vertices of the graph. Default is ones(nv(g)).\nverbose::Bool: (optional) Whether to print verbose output. Default is false.\n\nReturns\n\nTreeDecomposition: The resulting decomposition tree, where treewidht is stored in td.tw and the tree is stored in td.tree.\n\n\n\n\n\ndecomposition_tree(g::SimpleGraph{TG}, orders::Union{Vector{Vector{TE}}, Vector{TE}}; labels::Vector{TL} = [1:length(vertices(g))...]) where {TG, TE, TL}\n\nConstructs a decomposition tree for a given simple graph g based on the provided orders.\n\nArguments\n\ng::SimpleGraph{TG}: The input graph.\norders::Union{Vector{Vector{TE}}, Vector{TE}}: The orders for constructing the decomposition tree. Can be a vector of vectors or a single vector.\nlabels::Vector{TL}: (optional) The labels for the vertices of the graph. Default is collect(1:nv(g)).\n\nReturns\n\nTreeDecomposition: The resulting decomposition tree, where the tree is labeled according to the provided labels.\n\nRaises\n\nAssertionError: If the length of new_orders does not match the number of vertices in g, if new_orders contains duplicates, or if the length of labels does not match the length of new_orders.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"elimination_order","category":"page"},{"location":"manual/#TreeWidthSolver.elimination_order","page":"Manual","title":"TreeWidthSolver.elimination_order","text":"elimination_order(g::SimpleGraph{TG}; labels::Vector{TL} = collect(1:nv(g)), weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TL, TW}\n\nCompute the elimination order of a graph g using the BT algorithm.\n\nArguments\n\ng::SimpleGraph{TG}: The input graph.\nlabels::Vector{TL}: (optional) Labels for the vertices of g. Default is collect(1:nv(g)).\nweights::Vector{TW}: (optional) Weights for the vertices of g. Default is ones(nv(g)).\nverbose::Bool: (optional) Whether to print verbose output. Default is false.\n\nReturns\n\nlabeled_eo::Vector{Vector{TL}}: The elimination order of the graph g, where each vertex is labeled according to labels.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TreeWidthSolver","category":"page"},{"location":"#TreeWidthSolver.jl","page":"Home","title":"TreeWidthSolver.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TreeWidthSolver.","category":"page"},{"location":"","page":"Home","title":"Home","text":"TreeWidthSolver.jl is a Julia package for solving the treewidth problem. It provides a simple interface for solving the treewidth problem and generating tree decompositions. Currently we implemented the Bouchitté-Todinca algorithm for solving the treewidth problem, which is a exact algorithm for solving the treewidth problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details about the algorithms implemented in this package, please refer to the blog: https://arrogantgao.github.io/blogs/treewidth/.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is used as backend for finding the optimal tensor network contraction order in OMEinsumContractionOrders.jl, for more details please see the Contraction Order part.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, enter the package manager by pressing ] in the Julia REPL and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add TreeWidthSolver","category":"page"},{"location":"","page":"Home","title":"Home","text":"and everything should be set up.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The user interface of this package is quite simple, three functions are provided:","category":"page"},{"location":"","page":"Home","title":"Home","text":"exact_treewidth(g::SimpleGraph{TG}; weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TW}: Compute the exact treewidth of a given graph g using the BT algorithm.\ndecomposition_tree(g::SimpleGraph{TG}; labels::Vector{TL} = collect(1:nv(g)), weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TW, TL}: Compute the tree decomposition with minimal treewidth of a given graph g using the BT algorithm.\nelimination_order(g::SimpleGraph{TG}; labels::Vector{TL} = collect(1:nv(g)), weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TL, TW}: Compute the elimination order of a given graph g using the BT algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here are some examples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TreeWidthSolver, Graphs\n\njulia> g = smallgraph(:petersen)\n{10, 15} undirected simple Int64 graph\n\n# calculate the exact treewidth of the graph\njulia> exact_treewidth(g)\n4.0\n\n# show more information\njulia> exact_treewidth(g, verbose = true)\n[ Info: computing all minimal separators\n[ Info: allminseps: 10, 15\n[ Info: all minimal separators computed, total: 15\n[ Info: computing all potential maximal cliques\n[ Info: vertices: 9, Δ: 15, Π: 0\n[ Info: vertices: 8, Δ: 14, Π: 9\n[ Info: vertices: 7, Δ: 13, Π: 16\n[ Info: vertices: 6, Δ: 9, Π: 24\n[ Info: vertices: 5, Δ: 6, Π: 35\n[ Info: vertices: 4, Δ: 5, Π: 36\n[ Info: vertices: 3, Δ: 2, Π: 43\n[ Info: vertices: 2, Δ: 1, Π: 44\n[ Info: vertices: 1, Δ: 1, Π: 44\n[ Info: computing all potential maximal cliques done, total: 45\n[ Info: computing the exact treewidth using the Bouchitté-Todinca algorithm\n[ Info: precomputation phase\n[ Info: precomputation phase completed, total: 135\n[ Info: computing the exact treewidth done, treewidth: 4.0\n4.0\n\n# construct the tree decomposition\njulia> decomposition_tree(g)\ntree width: 4.0\ntree decomposition:\nSet([5, 6, 7, 3, 1])\n├─ Set([7, 2, 3, 1])\n├─ Set([5, 4, 6, 7, 3])\n│  └─ Set([4, 6, 7, 9])\n└─ Set([5, 6, 7, 10, 3])\n   └─ Set([6, 10, 8, 3])\n\n# similar for the elimination order\njulia> elimination_order(g)\n6-element Vector{Vector{Int64}}:\n [1, 3, 7, 6, 5]\n [10]\n [8]\n [4]\n [9]\n [2]\n\n# one can also assign labels to the vertices\njulia> elimination_order(g, labels = ['a':'j'...])\n6-element Vector{Vector{Char}}:\n ['a', 'c', 'g', 'f', 'e']\n ['j']\n ['h']\n ['d']\n ['i']\n ['b']","category":"page"},{"location":"#Questions-and-Contributions","page":"Home","title":"Questions and Contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have any questions or suggestions, please feel free to open an issue. It is also welcomed for any suggestions about the issues marked as enhancement, please let us know if you have any idea about them.","category":"page"}]
}
